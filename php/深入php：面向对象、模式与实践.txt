思考就是挖掘隐藏信息的过程  并对思考对象进行重新编码 以纳入自己的认知范畴

---所有对象 真实世界中"理解他的效率  理解它能提供的的接口"
"为接口而不是实现而编程" Program to an interface, not an implementation
人生  比脸皮厚的游戏  减少情绪消耗  表现出完整的自我


“if you're going through the hell, keep going."

这个世界 编码 组合 接口
建立一个对象树，来代表所遇到的标签。


创造系统的核心  自驱力 回到初始状态 有个循环 系统内部各个模块都暴露自己的接口 电脑 蒸汽机
而编码的核心 就是两个基本态 0和1
世界就是个大型的机器  哪怕自然也是  驱动力  循环  （停下） 启动

个体的量 总体的量  横向 纵向

发展的方向  1）遵循现有的接口   2）优化接口

太阳能提供了这个星球运转需要的驱动   我们发展出了各种子系统  然而这套 编码 组合 暴露核心接口的
编码方式没有变 （事实上 人类本身这个自驱力，真的很有可能是被设计出来的   植物也是）
基因的重新编码其实也很合理


__clone 有宣传拷贝  这个是浅拷贝  属性中有对象 要完全拷贝  这个属性也要clone


注册组件 回调:让一个类非常灵活  同时不会破坏类的核心功能
is_callable

利用use子句，就可以让匿名函数追踪来自其父作用域的变量
计时器  判断上限 统计边界判断

/com/getinstance/ 和com/getinstance 的区别  

get_class   字符串对比
instanceof  是否属于某个家族
get_class_methods()  is_callable  method_exists()
get_class_vars()
get_parent_class()
is_subclass_of()
class_implements()
call_user_func()
call_user_func_array()

ReflectionClass::getMethods()  看代码  反应  谁是谁 谁是谁的谁 ??面向对象  

一快多久头疼  大脑处理接口的速度就是这么快
而且好像还是和呼吸有关

通过文件名 来getInstance ParamHandler::getInstance("./params.xml");

if else  面向对象通过对象来处理 
类的设计原则
    可以把类的职责用多个词来形容，最好不超过25个词，不要用到词“且”或者“或”；

多态 类切换  是面向对象系统的基本特性之一;如果代码中存在大量条件语句，就说明需要使用多态；

php缺陷 方法返回类型  不能被确认
与关联   很相似   聚合aggregation 和组合composition 都描述了一个类长期持有其他类的一个或
多个示例的情况。（这个适是和客观世界最大差异的地方）

---------------
关联 线条
聚合 空心菱形 School StudentClass 
组合 (更强的关系) Person  SocialSecurityData
描述使用 （弱的对象引用）虚线加开放箭头
添加注释

继承  虚线空心三角  实线空心三角
-----------------
时序图 是基于对象而不是基于类的，它用于为系统中过程化的行为建模


设计模式概览
一个设计模式的核心由4部分组成：命名、问题、解决方案和效果；
优点一：便于学习  模式生来就是
    “可生成的”generative
    “可组成的”composable(各种模式的组成)

组合优于继承 （继承是纵向的类扩展  组合是横向的类扩张）所以这是个使用最广的模式  事物扩展的两个方面
"委托"
这种显示调用另一个对象的方法来执行一个请求的方式便是所谓的“委托”
还是if else  纵向的if else  横向的if else

几个关键模式
    生成对象模式
         单例模式  与全局变量   玩家信息变化公告板  变化的值 可以存到一个对象的属性中（改）
         工厂方法
         抽象工厂  类的功能 管理调度  执行逻辑  存储数据
         原型模式:抽象工厂模式的强大变形--原型模式  对传入的对象进行 clone == new ClassName（）前面的方法更加灵活
         单例和工厂模式的结合
    合并对象和类
         组合模式: 对象容器用的很多   是基类的组合对象同时又是子类并不冲突  多个对象容器 就好了
                  addUint()/removeUnit()
         装饰模式  运行时合并对象
         外观模式
    面向任务模式
    企业模式
    数据库模式